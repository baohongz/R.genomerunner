\documentclass[12pt, a4paper]{article}
\usepackage[OT1]{fontenc}
% prevents figures from floating out of their sections
\usepackage[section]{placeins} 
% get rid of whitespace
\usepackage{fullpage}
\usepackage[labelfont=bf]{caption}
\pagenumbering{gobble}

% https://tex.stackexchange.com/questions/41471/getting-sweave-code-chunks-to-stay-inside-page-margins
% \usepackage{listings}

\usepackage{hyperref}            
\hypersetup{pdfpagelayout=SinglePage} % http://www.tug.org/applications/hyperref/ftp/doc/manual.html
\setkeys{Gin}{width=0.8\textwidth}

\begin{document}
\title{Analysis of the enrichment and epigenomic similarity results: GWAS catalog example}
\author{Mikhail Dozmorov}
% \date{}
\maketitle

\section*{What will be done}

\begin{itemize}
  \item Disease- and trait-specific sets of SNPs from \href{http://www.genome.gov/gwastudies/}{GWAScatalog} will be analyzed for the enrichment in 161 transcription factor binding sites (TFBSs) using \href{http://www.genomerunner.org}{GenomeRunner Web};
  \item The results of the analysis will be loaded into R and pre-processed;
  \item Although \href{http://www.genomerunner.org}{GenomeRunner Web} has default visualization strategy, more visualization options will be explored;
  \item We will answer a question which epigenomic elements are differentially enriched in different clusters defined by the epigenomic similarity analysis;
  \item We will identify most strongly epigenomically correlated and anticorrelated sets of SNPs;
  \item We will visualize and tweak the enrichment analysis results.
\end{itemize}

<<setup, echo=F, include=FALSE, cache=F>>=
library(knitr) 
opts_chunk$set(cache.path='cache/', fig.path='img/', cache=T, tidy=T, fig.keep='high', echo=F, dpi=300)
options(replace.assign=TRUE, width=65)
#  listing <- function(x, options) {
#    paste("\\begin{lstlisting}[basicstyle=\\ttfamily,breaklines=true]\n",
#      x, "\\end{lstlisting}\n", sep = "")
#  }
#  knit_hooks$set(source=listing, output=listing)
@ 

\section*{Data analysis and preparation}
The results used in this tutorial have been obtained with \href{http://www.genomerunner.org}{GenomeRunner Web}. The details of the analysis and the BED files are available on \href{https://github.com/mdozmorov/gwas2bed}{https://github.com/mdozmorov/gwas2bed}. We will use the results from the \texttt{/data/more15\_vs\_tfbsEncode} folder. 

Load the libraries
<<loadLibraries, echo=TRUE, cache=FALSE>>=
source("utils.R")
suppressMessages(library(Hmisc)) # For rcorr function
suppressMessages(library(gplots))
suppressMessages(library(Biobase))
suppressMessages(library(limma))
@

The enrichment analysis results are outputted in the \texttt{matrix.txt} file, stored as the enrichment p-values with a "-" sign added to denote depletion. We transform the raw p-values using -log10 transformation, and keep the "-" sign for depletion.

<<loadData, echo=c(-7, -8, -10, -11)>>=
# Define output and data subfolders to use, change to analyze different data
rname<-"data//results//" # Output folder
# One or more GenomeRunner Web results data folders.
dname<-"data//more15_vs_tfbsEncode//"
mtx<-do.call("rbind", lapply(dname, function(fn) as.matrix(read.table(paste(fn, "matrix.txt", sep=""), sep="\t", header=T, row.names=1))))
# Optional: filter unused genomic features
# mtx<-mtx[grep("snp", rownames(mtx), ignore.case=T, invert=T), ]
mtx<-mtx.transform(mtx) # -log10 transform p-values
# Optional: adjust columns for multiple testing. See utils.R for the function definition.
# mtx<-mtx.adjust(mtx) 
@

Our matrix now contains the transformed p-values, negative in the case of depletion. Rows are the TFBSs names, columns are the names of disease- or trait-associated SNP sets. We remove the row if a corresponding TFBS does not show enrichment in any of the SNP sets. If a SNP set shows no enrichments in any of the TFBS, we remove the corresponding column as well. Check the final dimensions before actually trim the matrix.

<<preprocessData, echo=TRUE, cache=TRUE, dependson='loadData'>>=
dim(mtx) # Check original dimensions
# Define minimum number of times a row/col should have values above the cutoffs
numofsig<-1
cutoff<- -log10(0.01) # p-value significance cutoff
# What remains if we remove rows/cols with nothing significant
dim(mtx[apply(mtx, 1, function(x) sum(abs(x)>cutoff))>=numofsig, 
        apply(mtx, 2, function(x) sum(abs(x)>cutoff))>=numofsig])
# Trim the matrix
mtx<-mtx[apply(mtx, 1, function(x) sum(abs(x)>cutoff))>=numofsig, 
         apply(mtx, 2, function(x) sum(abs(x)>cutoff))>=numofsig]
@

\section*{Visualizing epigenomic similarity results}
Epigenomic similarity analysis groups SNP sets by correlation of their enrichemt profiles, or sets of the transformed p-values. In our matrix, SNP set-specific enrichment profiles are columns. We obtain a \emph{NxN} square matrix of correlation coefficients, where \emph{N} is the number of SNP sets. 

<<preprocessCorrel, echo=c(-1:-4), dependson='preprocessData'>>=
# rcorr returns a list, [[1]] - correl coeffs, [[3]] - p-values. Type - pearson/spearman
mtx.cor<-rcorr(as.matrix(mtx), type="spearman")
# Optionally, try kendall correlation
mtx.cor[[1]]<-cor(as.matrix(mtx), method="kendall")
@

We visualzie the matrix of correlation coefficients as a clustered heatmap (Figure \ref{fig:epigenomicVisualization}). Tweak distance and clustering parameters, or use a code snippet from \texttt{01\_heatmap\_corr.R} script for automated testing of combinations of them. 

<<epigenomicVisualization, echo=c(-1:-6), fig.cap='Epigenomic similarity heatmap', fig.show='hold', fig.height=6.5>>=
par(oma=c(5,0,0,5), mar=c(10, 4.1, 4.1, 5)) # Adjust margins
color<-colorRampPalette(c("blue","yellow")) # Define color gradient
# Adjust clustering parameters.
# Distance: "euclidean", "maximum","manhattan" or "minkowski". Do not use "canberra" or "binary"
# Clustering: "ward", "single", "complete", "average", "mcquitty", "median" or "centroid"
dist.method<-"euclidean"  
hclust.method<-"ward"
h<-heatmap.2(as.matrix(mtx.cor[[1]]), trace="none", density.info="none", col=color,distfun=function(x){dist(x, method=dist.method)}, hclustfun=function(x){hclust(x, method=hclust.method)}, cexRow=0.5, cexCol=0.5)
@

\section*{Epigenomic differences among the clusters}
The heatmap object contains information about the clustering. We visualize it as a dendrogram, cut into separate clusters defined by the cut height (defined empirically), and output the cluster ordering in a file. We also check the number of members in each cluster, and set the minimum number of members  for a cluster to be considered for differential enrichment.

<<defineClusters, echo=c(-1:-3), results='markup', fig=TRUE>>=
par(oma=c(0, 0, 0, 0), mar=c(5.1, 4.1, 4.1,25.1), cex=0.5)
# Plot the dendrogram only, limit y axis. attr(h$colDendrogram, "height") has the maximum height of the dendrogram.
plot(h$colDendrogram, horiz=T) 
# Cut the dentrogram into separate clusters. Tweak the height
abline(v=4) # Visually evaluate the height where to cut
c<-cut(h$colDendrogram, h=4) 
# Check the number of clusters, and the number of members.
for (i in 1:length(c$lower)){
  cat(paste("Cluster", formatC(i, width=2, flag="0"), sep=""), "has", formatC(attr(c$lower[[i]], "members"), width=3), "members", "\n")
}
# Output the results into a file
unlink(paste(rname, "clustering.txt", sep=""))
for (i in 1:length(c$lower)){ 
  write.table(paste(i, t(labels(c$lower[[i]])), sep="\t"), paste(rname, "clustering.txt", sep=""), sep="\t", col.names=F, row.names=F, append=T)
}
@

Our p-values are -log10-transformed. We will test whether these transformed p-values are different between the clusters using the Bioconductor $limma$ package.

First, we define the cluster groups and labels. Clusters that contain less than a minimum number of elements are not considered.

<<defineGroups, echo=TRUE, dependson='defineClusters'>>=
eset.labels<-character() # Empty vector to hold cluster labels
eset.groups<-numeric() # Empty vector to hold cluster groups
# Set the minimum number of members to be considered for the differential analysis
minmembers<-9
for (i in 1:length(c$lower)) { # Go through each cluster
  # If the number of members is more than a minimum number of members
  if (attr(c$lower[[i]], "members") > minmembers) { 
    eset.labels<-append(eset.labels, labels(c$lower[[i]]))
    eset.groups<-append(eset.groups, rep(i, length(labels(c$lower[[i]]))))
  }
}
@

Then, we perform a standard $limma$ analysis. That is, we construct an ExpressionSet, define a design matrix, the thresholds, and test each cluster combination for differential enrichment. We also define the \texttt{degs.matrix} matrix to contain just the numbers of differentially enriched epigenomic elements.

The results of $limma$ analysis are summarized in the \texttt{degs.txt} file.

<<limmaOnClusters, echo=TRUE, warning=FALSE, results='hide', dependson='defineGroups'>>=
eset<-new("ExpressionSet", exprs=as.matrix(mtx[, eset.labels]))
# Make model matrix
design<-model.matrix(~ 0+factor(eset.groups)) 
colnames(design)<-paste("c", unique(eset.groups), sep="")
# Create a square matrix of counts of DEGs
degs.matrix<-matrix(0, length(c$lower), length(c$lower))
colnames(degs.matrix)<-paste("c", seq(1,length(c$lower)), sep="")
rownames(degs.matrix)<-paste("c", seq(1, length(c$lower)), sep="") 
# Tweak p-value and log2 fold change cutoffs
cutoff.pval<-0.05
cutoff.lfc<-log2(2)
unlink(paste(rname, "degs.txt", sep=""))
for(i in colnames(design)){ 
  for(j in colnames(design)){
    # Test only unique pairs of clusters
    if (as.numeric(sub("c", "", i)) < as.numeric(sub("c", "", j))) {
      # Contrasts between two clusters
      contrast.matrix<-makeContrasts(contrasts=paste(i, j, sep="-"), levels=design)
      fit <- lmFit(eset, design) 
      fit2 <- contrasts.fit(fit, contrast.matrix)
      fit2 <- eBayes(fit2)
      degs<-topTable(fit2, number=dim(exprs(eset))[[1]], adjust.method="BH", p.value=cutoff.pval, lfc=cutoff.lfc)
      if(dim(degs)[[1]]>0) {
        print(paste(i, "vs.", j, ", number of degs:", dim(degs)[[1]]))
        # Keep the number of DEGs in the matrix
        degs.matrix[as.numeric(sub("c", "", i)), as.numeric(sub("c", "", j))]<-dim(degs)[[1]]
        # Average values in clusters i and j
        i.av<-rowMeans(matrix(exprs(eset)[rownames(degs), eset.groups == as.numeric(sub("c", "", i))], nrow=dim(degs)[[1]]))
        j.av<-rowMeans(matrix(exprs(eset)[rownames(degs), eset.groups == as.numeric(sub("c", "", j))], nrow=dim(degs)[[1]]))
        i.vs.j<-rep(paste(i,"vs.",j), dim(degs)[[1]])
        # Put it all together in a file, keeping columns with average transformed p-value being significant in at least one condition
        write.table(cbind(degs, i.vs.j, i.av, j.av)[abs(i.av) > -log10(cutoff.pval) || abs(j.av)> -log10(cutoff.pval),], paste(rname, "degs.txt", sep=""), sep="\t", col.names=NA, append=T)
      }
    }
  }
}
@

\section*{Most epigenomically (anti)correlated sets of SNPs}
Out of all epigenomic similarity results, the natural question may be: "What pair ofsets of SNPs show the strongest epigenomic similarity?", or "Which disease-specific SNP set most strongly correlates with Multiple Sclerosis SNP set?".

We simply scan each column of the correlation matrix and detect rows corresponding to minimum and maximum correlation coefficients. We want to ignore perfect self-correlations, therefore, we set the diagonal of the matrix containing such self-correlations to 0. We output the results in the \texttt{maxmin\_correlations.txt} file.
<<maxminCorr, echo=c(-6), eval=TRUE, results='hide', dependson='preprocessCorrel'>>=
mtx.cor1<-mtx.cor[[1]]
# We don't need to consider perfect correlations, zero them out
diag(mtx.cor1)<-0
# Print top correlated parameters on screen
for (i in head(unique(mtx.cor1[order(mtx.cor1,decreasing=T)]))) {print(which(mtx.cor1 == i, arr.ind=T))}
unlink(paste(rname, "maxmin_correlations.txt", sep=""))
for (i in 1:ncol(mtx.cor1)) write.table(paste(colnames(mtx.cor1)[i],"correlates with",
                                              colnames(mtx.cor1)[which(mtx.cor1[i,] == max(mtx.cor1[i,]))], 
                                              "at corr. coeff.",formatC(mtx.cor1[i,which(mtx.cor1[i,] == max(mtx.cor1[i,]))]),
                                              "anticorrelates with",
                                              colnames(mtx.cor1)[which(mtx.cor1[i,] == min(mtx.cor1[i,]))],
                                              "at corr. coeff.",formatC(mtx.cor1[i,which(mtx.cor1[i,] == min(mtx.cor1[i,]))]),sep=","),
                                        paste(rname, "maxmin_correlations.csv", sep=""), append=T, sep=",", col.names=F, row.names=F) 
@

\section*{Enrichment results visualization}
Clstering and  visualization of the enrichment results is the main heatmap generated by GenomeRunner. It is the fastest way to overview which epigenomic elements enriched where, and how strong. Due to large number of epigenomic elements typically used for the analysis, GenomeRunner filters those that do not show enrichment in any of the sets of SNPs. We will tweak the default filtering parameters to visualize the most significant enrichments.

First, we define the minimum number of times an epigenomic element should show statistically significant associations - at least once in this tutorial. Then, we investigate and set the transformed p-value and SD cutoffs. The higher the p-value cutoff - the more epigenomic elements will be filtered. The SD cutoff is used to filter out similarly enriched epigenomic elements and bring up the most differentially enriched epigenomic elements.

<<enrichmentCutoffs, echo=c(-1), eval=TRUE, results='hide', fig.show='asis', dependson='preprocessCorrel'>>=
par(oma=c(1, 0, 0, 0), mar=c(5.1, 4.1, 4.1,2.1), cex=1)
# Define minimum number of times a row/col should have values above the cutoffs
numofsig<-1
dim(mtx) # Original dimensions
# Check summary and set p-value and variability cutoffs as 3rd quantiles of their distributions
summary(as.vector(abs(mtx))); cutoff.p<-summary(as.vector(abs(mtx)))[[5]]
summary(as.vector(apply(abs(mtx),1,sd))); cutoff.sd<-summary(as.vector(apply(abs(mtx),1,sd)))[[5]]
# Check visual distributions and set p-value and variability cutoffs manually
hist(as.vector(mtx), breaks=50, main="Distribution of absolute -log10-transformed p-values", xlab="absolute -log10-transformed p-values")
hist(c(as.vector(apply(mtx,1,sd)), as.vector(apply(mtx,2,sd))), breaks=50, main="Distribution of SD across rows and columns", xlab="SD")
cutoff.p<- -log10(0.05); cutoff.sd<-0.8
@

We trim both rows and columns. We either take top 10 epigenomic elements most differentially enriched across the sets of SNPs, or trim by the p-value cutoff.

<<trimCutoffs, echo=TRUE, results='hide', dependson='enrichmentCutoffs'>>=
# Take top 10 most variably enriched elements
mtx.gf<-mtx[order(apply(mtx, 1, sd), decreasing=T)[1:10],]
# Or, remove rows/cols that do not show significant p-values less than numofsig times
# mtx.gf<-mtx[apply(mtx, 1, function(row){sum(abs(row)>cutoff.p)>=numofsig}), 
#             apply(mtx, 2, function(col){sum(abs(col)>cutoff.p)>=numofsig})]
# Remove sets of SNPs that do not show variability across the remaining rows
mtx.gf<-mtx.gf[apply(mtx.gf, 1, sd)>cutoff.sd,
               apply(mtx.gf, 2, sd)>cutoff.sd]
dim(mtx.gf) # Dimensions after trimming
@

We visualize weak/strong \texttt{relative} enrichments using blue/yellow gradient (Figure \ref{fig:enrichmentVisualization}). The \texttt{absolute} enrichment results visualization may be achieved by manually setting color breaks.

<<enrichmentVisualization, echo=c(-1:-4, -7:-11, -13, -14), results='hide', warning=FALSE, fig=TRUE, fig.cap='Heatmap of the enrichment results', fig.show='asis', dependson='trimCutoffs', dependson='enrichmentCutoffs'>>=
# Adjust clustering parameters.
# Distance: "euclidean", "maximum","manhattan", "canberra", "binary" or "minkowski".
# Clustering: "ward", "single", "complete", "average", "mcquitty", "median" or "centroid"
dist.method<-"maximum"
hclust.method<-"ward"
# granularity=7
# my.breaks<-c(seq(min(mtx.gf), -cutoff.p, length.out=granularity), seq(cutoff.p, max(mtx.gf), length.out=granularity)) 
# my.breaks<-c(seq(min(mtx.gf), -2, length.out=granularity), seq(2, max(mtx.gf), length.out=granularity))
my.breaks<-c(seq(min(mtx.gf), max(mtx.gf)))
par(oma=c(10, 0, 0, 0), mar=c(5.1, 4.1, 4.1,2.1), cex=0.5)
color<-colorRampPalette(c("blue", "yellow"))
h<-heatmap.2(as.matrix(mtx.gf), distfun=function(x){dist(x,method=dist.method)}, hclustfun=function(x){hclust(x,method=hclust.method)}, dendrogram="none", breaks=my.breaks,  col=color, lwid=c(1.5,3), lhei=c(1.5,4), key=T,  symkey=T, keysize=0.01, density.info="none", trace="none",  cexCol=1.0, cexRow=0.8)
@

This tutorial has been denerated on \today 

\Sexpr{version$version.string} on a \Sexpr{version$platform} platform.
\end{document} 
