---
title: "02_tumorportal-Barabasi"
author: "Mikhail Dozmorov"
date: "September 9, 2014"
output: html_document
---
```{r, echo=FALSE, warning=FALSE}
source("utils.R")
suppressMessages(library(Hmisc)) # For rcorr function
suppressMessages(library(gplots))
suppressMessages(library(Biobase))
suppressMessages(library(limma))
library(reshape)
# Set up the environment
library(knitr) 
opts_chunk$set(cache.path='cache/', fig.path='img/', cache=F, tidy=T, fig.keep='high', echo=T, dpi=300, out.width=700)
options(replace.assign=TRUE, width=120)
set.seed(1)
```

```{r loadData, echo=FALSE}
# Define output and data subfolders to use, change to analyze different data
rname<-"data//results//" # Output folder
# One or more GenomeRunner Web results data folders.
dname <- "data//tumorportal_vs_ENCODE/"
mtx<-do.call("rbind", lapply(dname, function(fn) as.matrix(read.table(paste(fn, "matrix.txt", sep=""), sep="\t", header=T, row.names=1))))
# Optional: filter unused genomic features
# mtx<-mtx[grep("snp", rownames(mtx), ignore.case=T, invert=T), ]
mtx<-mtx.transform(mtx) # -log10 transform p-values
# Read in deciphering of tumor abbreviations
tumorportal.names <- read.table("data/tumorportal.txt", sep="\t", row.names=1, header=F)
colnames(mtx) <- tumorportal.names[colnames(mtx), ]
# Optional: adjust columns for multiple testing. See utils.R for the function definition.
# mtx<-mtx.adjust(mtx) 
```

Input: a matrix of the -log10-transformed, corrected for multiple testing enrichment p-values, when testing 21 tumor-specific SNPs vs. all ENCODE data. The dimensions of the enrichment matrix:

```{r preprocessData, echo=FALSE}
dim(mtx) # Check original dimensions
```

After removing regulatory elements showing no enrichment in any of the tumor-associated SNPs, the dimensions become:

```{r preprocessData1, echo=FALSE}
# Define minimum number of times a row/col should have values above the cutoffs
numofsig<-1
cutoff<- -log10(0.1) # q-value significance cutoff
# What remains if we remove rows/cols with nothing significant
dim(mtx[apply(mtx, 1, function(x) sum(abs(x)>cutoff))>=numofsig, 
        apply(mtx, 2, function(x) sum(abs(x)>cutoff))>=numofsig])
# Trim the matrix
mtx<-mtx[apply(mtx, 1, function(x) sum(abs(x)>cutoff))>=numofsig, 
         apply(mtx, 2, function(x) sum(abs(x)>cutoff))>=numofsig]
```

```{r preprocessCorrel, echo=FALSE}
# rcorr returns a list, [[1]] - correl coeffs, [[3]] - p-values. Type - pearson/spearman
mtx.cor<-rcorr(as.matrix(mtx), type="spearman")
# Optionally, try kendall correlation
# mtx.cor[[1]]<-cor(as.matrix(mtx), method="kendall")
```

Visualization of Spearman correlation coefficients among tumor-specific regulatory enrichment profiles:

```{r epigenomicVisualization, echo=FALSE}
par(oma=c(5,0,0,5), mar=c(10, 4.1, 4.1, 5)) # Adjust margins
color<-colorRampPalette(c("blue","yellow")) # Define color gradient
#color<-greenred #Standard green-black-red palette
# Adjust clustering parameters.
# Distance: "euclidean", "maximum","manhattan" or "minkowski". Do not use "canberra" or "binary"
# Clustering: "ward", "single", "complete", "average", "mcquitty", "median" or "centroid"
dist.method<-"euclidean"  
hclust.method<-"ward.D2"
# Setting breaks to go from minimum to maximum correlation coefficients,
# excluding min/max outliers. This way we get rid of diagonale of 1's
granularity = 10
# Color gradient runs from second to minimum to second to maximum enrichment values
my.breaks <- seq(min(mtx.cor[[1]][mtx.cor[[1]]!=min(mtx.cor[[1]])]),
                 max(mtx.cor[[1]][mtx.cor[[1]]!=max(mtx.cor[[1]])]),
                 length.out=(2*granularity + 1))
h<-heatmap.2(as.matrix(mtx.cor[[1]]), trace="none", density.info="none", col=color, distfun=function(x){dist(x, method=dist.method)}, hclustfun=function(x){hclust(x, method=hclust.method)}, cexRow=0.7, cexCol=0.7, breaks=my.breaks)
```

Out of all tumor names, only the following can be mapped.

```{r diseaseNetwork, echo=FALSE}
# All disease-disease relationships
mtx.disease <- read.table("data//AllNet3.txt", sep="\t", header=F)
# Mapping of tumorportal IDs to ICD9 codes
tumorportal.mapping <- read.table("data/tumorportal_ICD9-3.txt", sep="\t", header=T, row.names=1)
tumorportal.mapping <- tumorportal.mapping[complete.cases(tumorportal.mapping),  ] # Remove non-ICD9 mapped
(tumorportal.mapping <- tumorportal.mapping[order(tumorportal.mapping$Name), ]) # Order by name
# Sanity check, is there differences in disease codes? Should be 0
# setdiff(unique(tumorportal.mapping$ICD.9.3.digits), unique(c(mtx.disease$V1, mtx.disease$V2)))
```

For those 14 mapped names, a square matrix of disease-disease co-morbitities is created. Its dimensions are:

```{r diseaseNetwork1, echo=FALSE}
# Create empty matrix of tumorportal disease-disease relationships
tumorportal.ICD9.mtx <- matrix(0, nrow=nrow(tumorportal.mapping), ncol=nrow(tumorportal.mapping))
rownames(tumorportal.ICD9.mtx) <- tumorportal.mapping$ICD.9.3.digits
colnames(tumorportal.ICD9.mtx) <- tumorportal.mapping$ICD.9.3.digits
# Populate this matrix with Barabasi relationship values
for (i in 1:nrow(tumorportal.ICD9.mtx)) {
  for (j in 1:ncol(tumorportal.ICD9.mtx)) {
    # Index is either col1 and col2, or col2 and col1
    idx <- mtx.disease$V1 == rownames(tumorportal.ICD9.mtx)[i] & mtx.disease$V2 == colnames(tumorportal.ICD9.mtx)[j] | 
      mtx.disease$V1 == rownames(tumorportal.ICD9.mtx)[j] & mtx.disease$V2 == colnames(tumorportal.ICD9.mtx)[i]
    if (sum(idx) == 1) {
      # If exactly one matching pair found
# V5 - Co-ocurrence between diseases 1 and 2
# V6 - Relative risk
# V9 - Phi-correlation
      tumorportal.ICD9.mtx[i, j] <- mtx.disease$V9[idx] # Save it in the matrix
      # cat(i, j, "\n")
    } else if (sum(idx) > 1) {
      # If there's more than one pair of the disease, print which one. Should be none
      cat(rownames(tumorportal.ICD9.mtx)[i], rownames(tumorportal.ICD9.mtx)[j], sum(idx))      
    }   
  }
}
dim(tumorportal.ICD9.mtx)
# Check the distribution of disease-disease relationship values
# summary(as.vector(tumorportal.ICD9.mtx))
# Replace diagonal (which is disease vs. the same disease) by maximum relationship
diag(tumorportal.ICD9.mtx) <- max(as.vector(tumorportal.ICD9.mtx)) + 0.01
```

For those mapped names, a matrix of Spearman correlation coefficients (regulatory similarity) is created.

```{r diseaseNetwork2, echo=FALSE}
# Create comparable correlation matrix
tumorportal.cor.mtx <- mtx.cor[[1]][rownames(mtx.cor[[1]]) %in% tumorportal.mapping$Name,
                                    colnames(mtx.cor[[1]]) %in% tumorportal.mapping$Name]
# Make alphabetical order of row/colnames
tumorportal.cor.mtx <- tumorportal.cor.mtx[order(rownames(tumorportal.cor.mtx)), order(colnames(tumorportal.cor.mtx))]
# Sanity check
# rownames(tumorportal.cor.mtx) == tumorportal.mapping$Name # Check the order match 
# colnames(tumorportal.cor.mtx) == tumorportal.mapping$Name # Should all be TRUE
rownames(tumorportal.cor.mtx) <- tumorportal.mapping$ICD.9.3.digits # Remap names to ICD9 codes
colnames(tumorportal.cor.mtx) <- tumorportal.mapping$ICD.9.3.digits
# rownames(tumorportal.cor.mtx) == rownames(tumorportal.ICD9.mtx) # Check the order match 
# colnames(tumorportal.cor.mtx) == colnames(tumorportal.ICD9.mtx) # Should all be TRUE
```

Evaluate heads of the matrixes, and get correlations between them. A matrix of correlation coefficients, a total number of pairs used for correlation measurement, and a matrix of p-values are outputted.

```{r diseaseNetwork3, echo=FALSE}
# Finally, check correlation between pairwise relationships
head(melt(tumorportal.cor.mtx)) # Check how melt look like
head(melt(tumorportal.ICD9.mtx)) 
# Get correlations
(rcorr(melt(tumorportal.cor.mtx)$value, melt(tumorportal.ICD9.mtx)$value, type="pearson"))
# V5 - Co-ocurrence between diseases 1 and 2, Pearson 0.53 (p=0), Spearman 0.28 (p=0)
# V6 - Relative risk, Pearson 0.52 (p=0), Spearman 0.23 (p=0.0002)
# V9 - Phi-correlation,  Pearson 0.56 (p=0), Spearman 0.24 (p=0)
```



```{r diseaseNetwork4, echo=FALSE, eval=FALSE}
# The diseases most different and similar when comparing regulatory similarity and comorbidities.
# Create a data frame for comparing correlations vs. ICD relationships
mtx.cor.ICD9 <- data.frame(disease1=melt(tumorportal.cor.mtx)$X1,
                           disease2=melt(tumorportal.cor.mtx)$X2,
                           x=melt(tumorportal.cor.mtx)$value,
                           y=melt(tumorportal.ICD9.mtx)$value)
# Replace ICD codes by disease names
for (i in 1:nrow(mtx.cor.ICD9)) {
  mtx.cor.ICD9$disease1[i] <- paste(tumorportal.mapping$Name[tumorportal.mapping$ICD.9.3.digits == mtx.cor.ICD9$disease1[i]], collapse="=")
  mtx.cor.ICD9$disease2[i] <- paste(tumorportal.mapping$Name[tumorportal.mapping$ICD.9.3.digits == mtx.cor.ICD9$disease2[i]], collapse="=")  
}
# Fit linear model 
fit <- lm(x ~ y, data=mtx.cor.ICD9)
# Get residuals
fit.res <- residuals(fit)
# Check their distribution
# summary(fit.res)
# Check most differentially related diseases
head(mtx.cor.ICD9[order(fit.res, decreasing=F), ])
head(mtx.cor.ICD9[order(fit.res, decreasing=T), ])
# Check most similarly related diseases
(mtx.cor.ICD9[fit.res < 0.01 & fit.res > -0.01, ])
```

```{r epigenomicVisualization1, echo=FALSE, eval=FALSE}
# Prepare matrixes for heatmap plotting by replacing ICD codes by disease names
colnames(tumorportal.cor.mtx) <- tumorportal.mapping$Name[match(colnames(tumorportal.cor.mtx), tumorportal.mapping$ICD.9.3.digits)]
rownames(tumorportal.cor.mtx) <- tumorportal.mapping$Name[match(rownames(tumorportal.cor.mtx), tumorportal.mapping$ICD.9.3.digits)]

colnames(tumorportal.ICD9.mtx) <- tumorportal.mapping$Name[match(colnames(tumorportal.ICD9.mtx), tumorportal.mapping$ICD.9.3.digits)]
rownames(tumorportal.ICD9.mtx) <- tumorportal.mapping$Name[match(rownames(tumorportal.ICD9.mtx), tumorportal.mapping$ICD.9.3.digits)]
# Visualize them in a single PDF
color<-colorRampPalette(c("blue","yellow")) # Define color gradient
#color<-greenred #Standard green-black-red palette
# Adjust clustering parameters.
# Distance: "euclidean", "maximum","manhattan" or "minkowski". Do not use "canberra" or "binary"
# Clustering: "ward", "single", "complete", "average", "mcquitty", "median" or "centroid"
dist.method<-"euclidean"  
hclust.method<-"ward.D2"
# Setting breaks to go from minimum to maximum correlation coefficients,
# excluding min/max outliers. This way we get rid of diagonale of 1's
granularity = 10

mtx.heatmap <- function(mtx) {
  my.breaks <- seq(min(mtx[mtx!=min(mtx)]), max(mtx[mtx!=max(mtx)]), length.out=(2*granularity + 1))
  h<-heatmap.2(as.matrix(mtx), trace="none", density.info="none", col=color, distfun=function(x){dist(x, method=dist.method)}, hclustfun=function(x){hclust(x, method=hclust.method)}, cexRow=0.7, cexCol=0.7, breaks=my.breaks)
}
pdf("results//tumorportal.pdf")
par(mfrow=c(1, 2))
par(oma=c(5,0,0,5), mar=c(10, 4.1, 4.1, 5)) # Adjust margins
mtx.heatmap(tumorportal.cor.mtx)
mtx.heatmap(tumorportal.ICD9.mtx)
dev.off()
```

