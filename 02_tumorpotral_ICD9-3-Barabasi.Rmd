---
title: "02_tumorportal-Barabasi"
author: "Mikhail Dozmorov"
date: "September 9, 2014"
output: html_document
---
```{r setup}
# Set up the environment
library(knitr) 
opts_chunk$set(cache.path='cache/', fig.path='img/', cache=T, tidy=T, fig.keep='high', echo=T, dpi=300, out.width=700)
options(replace.assign=TRUE, width=120)
set.seed(1)
```


```{r, echo=FALSE}
source("utils.R")
suppressMessages(library(Hmisc)) # For rcorr function
suppressMessages(library(gplots))
suppressMessages(library(Biobase))
suppressMessages(library(limma))
library(reshape)
```

```{r loadData, echo=FALSE}
# Define results and data subfolders to use, change to analyze different data
rname<-"results//" # Output folder
# One or more GenomeRunner Web results data folders.
dname <- "data//tumorportal_vs_ENCODE/"
mtx<-do.call("rbind", lapply(dname, function(fn) as.matrix(read.table(paste(fn, "matrix.txt", sep=""), sep="\t", header=T, row.names=1))))
# Optional: filter unused genomic features
# mtx<-mtx[grep("snp", rownames(mtx), ignore.case=T, invert=T), ]
mtx<-mtx.transform(mtx) # -log10 transform p-values
# Read in deciphering of tumor abbreviations
tumorportal.names <- read.table("data/tumorportal.txt", sep="\t", row.names=1, header=F)
colnames(mtx) <- tumorportal.names[colnames(mtx), ]
# Optional: adjust columns for multiple testing. See utils.R for the function definition.
# mtx<-mtx.adjust(mtx) 
```

```{r preprocessData, echo=FALSE}
dim(mtx) # Check original dimensions
# Define minimum number of times a row/col should have values above the cutoffs
numofsig<-1
cutoff<- -log10(0.1) # q-value significance cutoff
# What remains if we remove rows/cols with nothing significant
dim(mtx[apply(mtx, 1, function(x) sum(abs(x)>cutoff))>=numofsig, 
        apply(mtx, 2, function(x) sum(abs(x)>cutoff))>=numofsig])
# Trim the matrix
mtx<-mtx[apply(mtx, 1, function(x) sum(abs(x)>cutoff))>=numofsig, 
         apply(mtx, 2, function(x) sum(abs(x)>cutoff))>=numofsig]
```

```{r preprocessCorrel, echo=FALSE}
# rcorr returns a list, [[1]] - correl coeffs, [[3]] - p-values. Type - pearson/spearman
mtx.cor<-rcorr(as.matrix(mtx), type="spearman")
# Optionally, try kendall correlation
# mtx.cor[[1]]<-cor(as.matrix(mtx), method="kendall")
```

```{r epigenomicVisualization}
par(oma=c(5,0,0,5), mar=c(10, 4.1, 4.1, 5)) # Adjust margins
color<-colorRampPalette(c("blue","yellow")) # Define color gradient
#color<-greenred #Standard green-black-red palette
# Adjust clustering parameters.
# Distance: "euclidean", "maximum","manhattan" or "minkowski". Do not use "canberra" or "binary"
# Clustering: "ward", "single", "complete", "average", "mcquitty", "median" or "centroid"
dist.method<-"euclidean"  
hclust.method<-"ward.D2"
# Setting breaks to go from minimum to maximum correlation coefficients,
# excluding min/max outliers. This way we get rid of diagonale of 1's
granularity = 10
my.breaks <- seq(min(mtx.cor[[1]][mtx.cor[[1]]!=min(mtx.cor[[1]])]),
                 max(mtx.cor[[1]][mtx.cor[[1]]!=max(mtx.cor[[1]])]),
                 length.out=(2*granularity + 1))
h<-heatmap.2(as.matrix(mtx.cor[[1]]), trace="none", density.info="none", col=color, distfun=function(x){dist(x, method=dist.method)}, hclustfun=function(x){hclust(x, method=hclust.method)}, cexRow=0.7, cexCol=0.7, breaks=my.breaks)
write.table(h$carpet, paste(rname, "tumorportal_mtx_clustered.txt", sep="/"), sep="\t", col.names=NA)
```

```{r diseaseNetwork, echo=FALSE}
# All disease-disease relationships
mtx.disease <- read.table("data//AllNet3.net", sep="\t", header=F)
# Mapping of tumorportal IDs to ICD9 codes
tumorportal.mapping <- read.table("data/tumorportal_ICD9.txt", sep="\t", header=T, row.names=1)
tumorportal.mapping <- tumorportal.mapping[order(tumorportal.mapping$Name), ] # Order by name
# Sanity check, is there differences in disease codes? Should be 0
setdiff(tumorportal.mapping$ICD.9.Code, mtx.disease$V1)
# Create empty matrix of tumorportal disease-disease relationships
tumorportal.IDC9.mtx <- matrix(0, nrow=nrow(tumorportal.mapping), ncol=nrow(tumorportal.mapping))
rownames(tumorportal.IDC9.mtx) <- tumorportal.mapping$ICD.9.Code
colnames(tumorportal.IDC9.mtx) <- tumorportal.mapping$ICD.9.Code
# Populate this matrix with Barabasi relationship values
for (i in 1:nrow(tumorportal.IDC9.mtx)) {
  for (j in 1:ncol(tumorportal.IDC9.mtx)) {
    # Index is either col1 and col2, or col2 and col1
    idx <- mtx.disease$V1 == rownames(tumorportal.IDC9.mtx)[i] & mtx.disease$V2 == colnames(tumorportal.IDC9.mtx)[j] | 
      mtx.disease$V1 == rownames(tumorportal.IDC9.mtx)[j] & mtx.disease$V2 == colnames(tumorportal.IDC9.mtx)[i]
    if (sum(idx) == 1) {
      # If exactly one matching pair found
# V5 - Co-ocurrence between diseases 1 and 2
# V6 - Relative risk
# V9 - Phi-correlation
      tumorportal.IDC9.mtx[i, j] <- mtx.disease$V9[idx] # Save it in the matrix
      cat(i, j, "\n")
    } else if (sum(idx) > 1) {
      # If there's more than one pair of the disease, print which one. Should be none
      cat(rownames(tumorportal.IDC9.mtx)[i], rownames(tumorportal.IDC9.mtx)[j], sum(idx))      
    }   
  }
}
# Replace diagonal (which is disease vs. the same disease) by maximum relationship
diag(tumorportal.IDC9.mtx) <- max(as.vector(tumorportal.IDC9.mtx)) + 0.1
```

```{r diseaseCorrelations}
# Check the distribution of disease-disease relationship values
summary(as.vector(tumorportal.IDC9.mtx))
# Create comparable correlation matrix, with alphabetical order of row/colnames
tumorportal.cor.mtx <- mtx.cor[[1]][order(rownames(mtx.cor[[1]])), order(colnames(mtx.cor[[1]]))]
# Perform sanity check, to ensure order of columns in correlation and ICD matrixes are same
rownames(tumorportal.cor.mtx) == tumorportal.mapping$Name # Check the order match 
colnames(tumorportal.cor.mtx) == tumorportal.mapping$Name # Should all be TRUE
colnames(tumorportal.cor.mtx) <- tumorportal.mapping$ICD.9.Code # Remap names to ICD9 codes
rownames(tumorportal.cor.mtx) <- tumorportal.mapping$ICD.9.Code # Note that Markdown breaks 
rownames(tumorportal.cor.mtx) == rownames(tumorportal.IDC9.mtx) # Check the order match 
colnames(tumorportal.cor.mtx) == colnames(tumorportal.IDC9.mtx) # Should all be TRUE
# Finally, check correlation between pairwise relationships
head(melt(tumorportal.cor.mtx)) # Check how melt look like
head(melt(tumorportal.IDC9.mtx)) 
# Get correlations
rcorr(melt(tumorportal.cor.mtx)$value, melt(tumorportal.IDC9.mtx)$value, type="pearson") 
# V5 - Co-ocurrence between diseases 1 and 2, Pearson 0.42 (p=0), Spearman 0.14 (p=0.0026)
# V6 - Relative risk, Pearson 0.43 (p=0), Spearman 0.18 (p=0.0002)
# V9 - Phi-correlation,  Pearson 0.45 (p=0), Spearman 0.21 (p=0)
# Create a data frame for comparing correlations vs. ICD relationships
mtx.cor.ICD9 <- data.frame(disease1=melt(tumorportal.cor.mtx)$X1,
                           disease2=melt(tumorportal.cor.mtx)$X2,
                           x=melt(tumorportal.cor.mtx)$value,
                           y=melt(tumorportal.IDC9.mtx)$value)
# Replace ICD codes by disease names
for (i in 1:nrow(mtx.cor.ICD9)) {
  mtx.cor.ICD9$disease1[i] <- paste(tumorportal.mapping$Name[tumorportal.mapping$ICD.9.Code == mtx.cor.ICD9$disease1[i]], collapse="=")
  mtx.cor.ICD9$disease2[i] <- paste(tumorportal.mapping$Name[tumorportal.mapping$ICD.9.Code == mtx.cor.ICD9$disease2[i]], collapse="=")  
}
# Fit linear model 
fit <- lm(x ~ y, data=mtx.cor.ICD9)
# Get residuals
fit.res <- residuals(fit)
# Check their distribution
summary(fit.res)
# Check most differentially related diseases
head(mtx.cor.ICD9[order(fit.res, decreasing=F), ])
head(mtx.cor.ICD9[order(fit.res, decreasing=T), ])
# Check most similarly related diseases
(mtx.cor.ICD9[fit.res < 0.02 & fit.res > -0.02, ])
```

